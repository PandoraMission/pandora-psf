{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#pandorapsf","title":"pandorapsf","text":"<p>This is a standalone tool for working with the NASA Pandora Mission PSF. This can be used to model the expected distribution of starlight on the detector.</p>"},{"location":"#installation","title":"Installation","text":"<p>To install you can use</p> <pre><code>pip install pandorapsf --upgrade\n</code></pre> <p>You should update your package often, as we frequently put out new versions with updated Current Best Estimates, and some limited new functionality. Check your version number using</p> <pre><code>import pandorapsf as ppsf\nppsf.__version__\n</code></pre>"},{"location":"#configuration","title":"Configuration","text":"<p><code>pandorapsf</code> has a configuration system. This determines where <code>pandorapsf</code> will expect your data to be stored.</p> <p>Users can find where the configuration file is stored using</p> <pre><code>from pandorapsf import CONFIGDIR\nprint(CONFIGDIR)\n</code></pre> <p>You can display your current configuration using</p> <pre><code>from pandorapsf import display_config\ndisplay_config()\n</code></pre> <p>You can access particular configuration parameters using</p> <p>You can display your current configuration, for example use the following to find the <code>data_dir</code> parameter.</p> <pre><code>from pandorapsf import config\nconfig[\"SETTINGS\"][\"data_dir\"]\n</code></pre> <p>You can update the configuration either by updating the <code>config.ini</code> file in your <code>CONFIRDIR</code> or you can update them in your environment using <code>save_config</code>, e.g.</p> <pre><code>from pandorapsf import save_config\nconfig[\"SETTINGS\"][\"log_level\"] = \"INFO\"\nsave_config(config)\n</code></pre> <p>If you want to reset back to defaults you can use</p> <pre><code>from pandorapsf import reset_config\nreset_config()\n</code></pre>"},{"location":"#configuration-parameters","title":"Configuration Parameters","text":"<p>Below is a table of all the configuration parameters in <code>pandorapsf</code> and their current defaults</p> (section, key) Description ('SETTINGS', 'data_dir') Where data will be stored for the package. This includes ~0.5Gb of PSF files which will be downloaded. ('SETTINGS', 'log_level') Default level for the logger. Change this to make the tool more or less verbose by default. ('SETTINGS', 'vis_psf_download_location') Where the visible channel PSF file is located online for download. ('SETTINGS', 'nir_psf_download_location') Where the NIR channel PSF file is located online for download. ('SETTINGS', 'vis_psf_creation_date') This is the string provided in the \"CREATION\" keyword of the PSF fits file header. This will be used to verify that the PSF file is the correct version. ('SETTINGS', 'nir_psf_creation_date') This is the string provided in the \"CREATION\" keyword of the PSF fits file header. This will be used to verify that the PSF file is the correct version."},{"location":"#obtaining-psf-files","title":"Obtaining PSF files","text":"<p>When you install this tool you will additionally need to download the PSF grid online. This grid will be updated periodically as we improve our estimates of Pandora's performance. <code>pandorapsf</code> will download the files for you and put them in your configured data directory.</p> <p>As we release new versions of <code>pandorapsf</code>, the default configuration will change to point to new PSF files that contain our new best estimates. Keep your <code>pandorapsf</code> version up to date to ensure you have the most recent changes.</p>"},{"location":"#dependencies","title":"Dependencies","text":"<p>This tool depends on <code>sparse3d</code> which implements the sparse matrix maths needed to quickly model scenes.</p>"},{"location":"PSF/","title":"PSF Class","text":"<p>This class implements tools needed to work with the PSF. Below is an example of the Pandora PSF in pixel space. This class enables users to work with the PSF files and</p> <ul> <li>Evaluate it at any grid point (e.g. position, temperature, wavelength)</li> <li>Evaluate the PRF (i.e. the PSF integrated on a pixel grid)</li> <li>Find the gradient of the PSF or PRF</li> </ul> <p></p> <p>Class to work with abstract PSFs</p> <p>PSF class for making PSFs, PRFs, and traces.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Array of 1D vectors defining the value of each dimension for every element of <code>psf_flux</code>. Should have as many entries as <code>psf_flux</code> has dimensions.</p> required <code>psf_flux</code> <code>ndarray</code> <p>ND array of flux values</p> required <code>dimension_names</code> <code>List</code> <p>List of names for each of the N dimensions in <code>psf_flux</code></p> required <code>dimension_units</code> <code>List</code> <p>List of <code>astropy.unit.Quantity</code>'s describing units of each dimension</p> required <code>pixel_size</code> <code>Quantity</code> <p>True detector pixel size in dimensions of length/pixel</p> required <code>sub_pixel_size</code> <code>Quantity</code> <p>PSF file pixel size in dimensions of length/pixel</p> required <code>transpose</code> <code>bool</code> <p>Whether to transpose the input data in the column/row axis.</p> <code>False</code> <code>freeze_dictionary</code> <code>Dict</code> <p>Dictionary of dimensions to freeze</p> <code>{}</code> <code>check_bounds</code> <code>bool</code> <p>Whether to check if the inputs are within the bounds of the PSF model and have the right units. This check causes a small slowdown.</p> <code>True</code> <code>extrapolate</code> <code>bool</code> <p>Whether to allow the PSF to be evaluated outside of the bounds (i.e. will extrapolate)</p> <code>False</code> <code>scale</code> <code>int</code> <p>How much to scale the PSF grid. Scale of 2 makes the PSF 2x broader. Default is 1.</p> <code>1</code> <code>bin</code> <code>int</code> <p>('Optional amount to bin the input PSF file by. Binning the PSF file will result in faster computation, but less accurate modeling. Default is 1.',)</p> <code>1</code>"},{"location":"PSF/#pandorapsf.psf.PSF.trace_pixel","title":"<code>trace_pixel</code>  <code>property</code>","text":"<p>Pixels corresponding to <code>self.trace_sensitivity</code></p>"},{"location":"PSF/#pandorapsf.psf.PSF.trace_sensitivity","title":"<code>trace_sensitivity</code>  <code>property</code>","text":"<p>The sensitivity of a spectrum trace at the <code>self.trace_wavelength</code> and <code>self.trace_pixel</code> positions.</p>"},{"location":"PSF/#pandorapsf.psf.PSF.trace_wavelength","title":"<code>trace_wavelength</code>  <code>property</code>","text":"<p>Wavelengths corresponding to <code>self.trace_sensitivity</code></p>"},{"location":"PSF/#pandorapsf.psf.PSF.freeze_dimension","title":"<code>freeze_dimension(**kwargs)</code>","text":"<p>Drop a dimension of the PSF model. Dropped dimension must exist in self.dimension_names.</p> <p>Examples:</p> <p>Freeze a PSF object <code>p</code> to have row of 10 pixels and wavelength of 1.3 microns</p> <pre><code>&gt;&gt;&gt; p.freeze_dimension(row=10*u.pixel, wavelength=1.3*u.micron)\n</code></pre> <p>Returns:</p> Name Type Description <code>new</code> <code>PSF</code> <p>New PSF object</p>"},{"location":"PSF/#pandorapsf.psf.PSF.from_file","title":"<code>from_file(name, file='/home/runner/work/pandora-psf/pandora-psf/src/pandorapsf/data/pandora_vis_2024-05.fits', transpose=False, extrapolate=False, scale=1, bin=1)</code>","text":"<p>Build a PSF class from an input fits file.</p> <pre><code>    Parameters:\n</code></pre> <p>name: str     Name of detector transpose: bool     Whether to transpose the input data in the column/row axis. extrapolate: bool     Whether to allow the PSF to be evaluated outside of the bounds (i.e. will extrapolate) scale: float     How much to scale the PSF grid. Scale of 2 makes the PSF 2x broader. Default is 1. bin: int     ('Optional amount to bin the input PSF file by. Binning the PSF file will result in faster computation, but less accurate modeling. Default is 1.',)         file: str or fits.HDUList             Filename of PSF fits file, or opened hdulist. PSF cube must have a shape such that the first             two dimensions are the x and y extent of the PSF. Defaults to visible PSF.         transpose: bool             Transpose the input file, i.e. rotate 90 degrees</p> <pre><code>    Returns:\n</code></pre> <pre><code>    psf : pandorapsf.PSF\n        Returns a PSF object\n</code></pre>"},{"location":"PSF/#pandorapsf.psf.PSF.from_name","title":"<code>from_name(name, transpose=False, scale=1, bin=1)</code>  <code>staticmethod</code>","text":"<p>Open a PSF file based on the detector name. This will automatically freeze dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of detector</p> required <code>transpose</code> <code>bool</code> <p>Whether to transpose the input data in the column/row axis.</p> <code>False</code> <code>scale</code> <code>int</code> <p>How much to scale the PSF grid. Scale of 2 makes the PSF 2x broader. Default is 1.</p> <code>1</code> <code>bin</code> <code>int</code> <p>('Optional amount to bin the input PSF file by. Binning the PSF file will result in faster computation, but less accurate modeling. Default is 1.',)</p> <code>1</code>"},{"location":"PSF/#pandorapsf.psf.PSF.integrate_spectrum","title":"<code>integrate_spectrum(wavelength, spectrum, wavelength_grid=None)</code>","text":"<p>Create an integrated spectrum, integrated over wavelength bounds.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>ndarray</code> <p>Array of wavelength values. If no wavelength unit is present, assumed to be in microns.</p> required <code>spectrum</code> <code>ndarray</code> <p>Array of spectrum intensity values. Should have units of erg / (Angstrom s cm2).</p> required <code>wavelength_grid</code> <code>ndarray</code> <p>Optional wavelength grid at which to integrate. If no grid is provided, will default to the <code>trace_wavelength</code> grid of this object.</p> <code>None</code>"},{"location":"PSF/#pandorapsf.psf.PSF.integrate_wavelength","title":"<code>integrate_wavelength(teff=5500, logg=4.5, **kwargs)</code>","text":"<p>Inte</p> <p>Parameters:</p> Name Type Description Default <code>teff</code> <p>Effective temperature of a star in K.</p> <code>5500</code> <code>logg</code> <p>Surface gravity of a star. log(g)</p> <code>4.5</code>"},{"location":"PSF/#pandorapsf.psf.PSF.prf","title":"<code>prf(row, column, gradients=False, **kwargs)</code>","text":"<p>Bins the PSF down to the pixel scale.</p> <p>Returns:</p> Name Type Description <code>row_array</code> <code>NDArray</code> <p>Array of integer row positions</p> <code>column_array</code> <code>NDArray</code> <p>Array of integer column positions</p> <code>prf</code> <code>ndarray</code> <p>2D array of PRF flux values with shape (nrows, ncolumns)</p> <p>Parameters:</p> Name Type Description Default <code>row</code> <p>Row position on the detector</p> required <code>column</code> <p>Column position on the detector</p> required <code>gradients</code> <p>Whether to return gradients. If True, will return an additional 2 arrays that contain the gradients in each axis.</p> <code>False</code>"},{"location":"PSF/#pandorapsf.psf.PSF.psf","title":"<code>psf(gradients=False, **kwargs)</code>","text":"<p>Interpolate the PSF cube to a particular point</p> <p>Returns:</p> Name Type Description <code>ar</code> <code>np.ndarray of shape self.shape</code> <p>The interpolated PSF</p> <p>Parameters:</p> Name Type Description Default <code>gradients</code> <p>Whether to return gradients. If True, will return an additional 2 arrays that contain the gradients in each axis.</p> <code>False</code>"},{"location":"Scene/","title":"Scene Class","text":"<p>Class for working with scenes of many PSFs</p> <p>Parameters:</p> Name Type Description Default <code>locations</code> <code>Union[_SupportsArray[dtype[Any]], _NestedSequence[_SupportsArray[dtype[Any]]], bool, int, float, complex, str, bytes, _NestedSequence[Union[bool, int, float, complex, str, bytes]]]</code> <p>Set of locations in row and column for every source.</p> required <code>psf</code> <code>PSF</code> <p>A PSF object to use within the scene.</p> <code>None</code> <code>scale</code> <code>int</code> <p>How much to scale the PSF grid. Scale of 2 makes the PSF 2x broader. Default is 1.</p> <code>1</code>"},{"location":"Scene/#pandorapsf.scene.Scene.fit_images","title":"<code>fit_images(imgs, prior_mu=None, prior_sigma=None, fit_shifts=False)</code>","text":"<p>Fit a stack of images with the PRF model</p>"},{"location":"Scene/#pandorapsf.scene.Scene.model","title":"<code>model(flux, delta_pos=None, quiet=False, downsample=False)</code>","text":"Parameters: <p>flux : npt.ArrayLike     Array of flux values with shape (ntargets, ntimes) delta_pos : npt.ArrayLike     Array of jitter values in row and column, has shape (2, ntimes)</p>"},{"location":"Scene/#roiscene-class","title":"ROIScene Class","text":"<p>               Bases: <code>pandorapsf.scene.Scene</code></p>"},{"location":"Scene/#pandorapsf.scene.ROIScene.fit_images","title":"<code>fit_images(imgs, prior_mu=None, prior_sigma=None, fit_shifts=False)</code>","text":"<p>Fit a stack of images with the PRF model</p>"},{"location":"Scene/#pandorapsf.scene.ROIScene.model","title":"<code>model(flux, delta_pos=None, quiet=False, downsample=False)</code>","text":"Parameters: <p>flux : npt.ArrayLike     Array of flux values with shape (ntargets, ntimes) delta_pos : npt.ArrayLike     Array of jitter values in row and column, has shape (2, ntimes)</p>"},{"location":"Scene/#tracescene-class","title":"TraceScene Class","text":"<p>               Bases: <code>pandorapsf.scene.Scene</code></p>"},{"location":"Scene/#pandorapsf.scene.TraceScene.fit_images","title":"<code>fit_images(imgs, prior_mu=None, prior_sigma=None, fit_shifts=False)</code>","text":"<p>Fit a stack of images with the PRF model</p>"},{"location":"Scene/#pandorapsf.scene.TraceScene.model","title":"<code>model(spectra, delta_pos=None, quiet=False, downsample=False)</code>","text":"<p><code>spectra</code> must have shape nwav x ntargets x ntime</p>"},{"location":"example-psf/","title":"PSF Class Example","text":"In\u00a0[1]: Copied! <pre>from pandorapsf import PSF\nimport pandorasat as ps\n</pre> from pandorapsf import PSF import pandorasat as ps In\u00a0[2]: Copied! <pre>ps.utils.SED(4000, jmag=10)[1].unit.to_string()\n</pre> ps.utils.SED(4000, jmag=10)[1].unit.to_string() Out[2]: <pre>'erg / (Angstrom s cm2)'</pre> <p>We can initialize the object in a few ways, but for most purposes you will want to use the <code>from_name</code> method to get the current best estimate of the PSF for either channel in Pandora.</p> In\u00a0[3]: Copied! <pre>PSF?\n</pre> PSF? <pre>Init signature:\nPSF(\n    name: str,\n    X: numpy.ndarray[typing.Any, numpy.dtype[+_ScalarType_co]],\n    psf_flux: numpy.ndarray[typing.Any, numpy.dtype[+_ScalarType_co]],\n    dimension_names: List,\n    dimension_units: List,\n    pixel_size: astropy.units.quantity.Quantity,\n    sub_pixel_size: astropy.units.quantity.Quantity,\n    transpose: bool = False,\n    freeze_dictionary: Dict = {},\n    check_bounds: bool = True,\n    extrapolate: bool = False,\n    scale: int = 1,\n    bin: int = 1,\n)\nDocstring:      Class to work with abstract PSFs\nInit docstring:\nPSF class for making PSFs, PRFs, and traces.\n\n\nParameters\n----------\nX: ndarray\n    Array of 1D vectors defining the value of each dimension for every element of `psf_flux`. Should have as many entries as `psf_flux` has dimensions.\npsf_flux: ndarray\n    ND array of flux values\ndimension_names: list\n    List of names for each of the N dimensions in `psf_flux`\ndimension_units: list\n    List of `astropy.unit.Quantity`'s describing units of each dimension\npixel_size: Quantity\n    True detector pixel size in dimensions of length/pixel\nsub_pixel_size: Quantity\n    PSF file pixel size in dimensions of length/pixel\ntranspose: bool\n    Whether to transpose the input data in the column/row axis.\nfreeze_dictionary: dict\n    Dictionary of dimensions to freeze\ncheck_bounds: bool\n    Whether to check if the inputs are within the bounds of the PSF model and have the right units. This check causes a small slowdown.\nextrapolate: bool\n    Whether to allow the PSF to be evaluated outside of the bounds (i.e. will extrapolate)\nscale: float\n    How much to scale the PSF grid. Scale of 2 makes the PSF 2x broader. Default is 1.\nbin: int\n    ('Optional amount to bin the input PSF file by. Binning the PSF file will result in faster computation, but less accurate modeling. Default is 1.',)\nFile:           ~/Pandora/repos/pandora-psf/src/pandorapsf/psf.py\nType:           type\nSubclasses:     </pre> In\u00a0[4]: Copied! <pre>PSF.from_name?\n</pre> PSF.from_name? <pre>Signature:\nPSF.from_name(\n    name: str,\n    transpose: bool = False,\n    scale: int = 1,\n    bin: int = 1,\n)\nDocstring:\nOpen a PSF file based on the detector name. This will automatically freeze dimensions.\n\nParameters\n----------\nname: str\n    Name of detector\ntranspose: bool\n    Whether to transpose the input data in the column/row axis.\nscale: float\n    How much to scale the PSF grid. Scale of 2 makes the PSF 2x broader. Default is 1.\nbin: int\n    ('Optional amount to bin the input PSF file by. Binning the PSF file will result in faster computation, but less accurate modeling. Default is 1.',)\nFile:      ~/Pandora/repos/pandora-psf/src/pandorapsf/psf.py\nType:      function</pre> In\u00a0[5]: Copied! <pre>p = PSF.from_name(\"NIRDA\")\n</pre> p = PSF.from_name(\"NIRDA\") In\u00a0[6]: Copied! <pre>p\n</pre> p Out[6]: <pre>3D PSF Model [row, column, wavelength]</pre> <p>This PSF is 3D and has row, column, and wavelength dimensions. The grid of each of these values is given inside the object</p> In\u00a0[7]: Copied! <pre>p.row.shape\n</pre> p.row.shape Out[7]: <pre>(9, 9, 11)</pre> In\u00a0[8]: Copied! <pre>p.column.shape\n</pre> p.column.shape Out[8]: <pre>(9, 9, 11)</pre> In\u00a0[9]: Copied! <pre>p.wavelength.shape\n</pre> p.wavelength.shape Out[9]: <pre>(9, 9, 11)</pre> <p>We can look at this grid</p> In\u00a0[10]: Copied! <pre>p.wavelength\n</pre> p.wavelength Out[10]:  $[[[1,~1.0700001,~1.14,~\\dots,~1.5599999,~1.63,~1.7],~   [1,~1.0700001,~1.14,~\\dots,~1.5599999,~1.63,~1.7],~   [1,~1.0700001,~1.14,~\\dots,~1.5599999,~1.63,~1.7],~   \\dots,~   [1,~1.0700001,~1.14,~\\dots,~1.5599999,~1.63,~1.7],~   [1,~1.0700001,~1.14,~\\dots,~1.5599999,~1.63,~1.7],~   [1,~1.0700001,~1.14,~\\dots,~1.5599999,~1.63,~1.7]],~   [[1,~1.0700001,~1.14,~\\dots,~1.5599999,~1.63,~1.7],~   [1,~1.0700001,~1.14,~\\dots,~1.5599999,~1.63,~1.7],~   [1,~1.0700001,~1.14,~\\dots,~1.5599999,~1.63,~1.7],~   \\dots,~   [1,~1.0700001,~1.14,~\\dots,~1.5599999,~1.63,~1.7],~   [1,~1.0700001,~1.14,~\\dots,~1.5599999,~1.63,~1.7],~   [1,~1.0700001,~1.14,~\\dots,~1.5599999,~1.63,~1.7]],~   [[1,~1.0700001,~1.14,~\\dots,~1.5599999,~1.63,~1.7],~   [1,~1.0700001,~1.14,~\\dots,~1.5599999,~1.63,~1.7],~   [1,~1.0700001,~1.14,~\\dots,~1.5599999,~1.63,~1.7],~   \\dots,~   [1,~1.0700001,~1.14,~\\dots,~1.5599999,~1.63,~1.7],~   [1,~1.0700001,~1.14,~\\dots,~1.5599999,~1.63,~1.7],~   [1,~1.0700001,~1.14,~\\dots,~1.5599999,~1.63,~1.7]],~   \\dots,~   [[1,~1.0700001,~1.14,~\\dots,~1.5599999,~1.63,~1.7],~   [1,~1.0700001,~1.14,~\\dots,~1.5599999,~1.63,~1.7],~   [1,~1.0700001,~1.14,~\\dots,~1.5599999,~1.63,~1.7],~   \\dots,~   [1,~1.0700001,~1.14,~\\dots,~1.5599999,~1.63,~1.7],~   [1,~1.0700001,~1.14,~\\dots,~1.5599999,~1.63,~1.7],~   [1,~1.0700001,~1.14,~\\dots,~1.5599999,~1.63,~1.7]],~   [[1,~1.0700001,~1.14,~\\dots,~1.5599999,~1.63,~1.7],~   [1,~1.0700001,~1.14,~\\dots,~1.5599999,~1.63,~1.7],~   [1,~1.0700001,~1.14,~\\dots,~1.5599999,~1.63,~1.7],~   \\dots,~   [1,~1.0700001,~1.14,~\\dots,~1.5599999,~1.63,~1.7],~   [1,~1.0700001,~1.14,~\\dots,~1.5599999,~1.63,~1.7],~   [1,~1.0700001,~1.14,~\\dots,~1.5599999,~1.63,~1.7]],~   [[1,~1.0700001,~1.14,~\\dots,~1.5599999,~1.63,~1.7],~   [1,~1.0700001,~1.14,~\\dots,~1.5599999,~1.63,~1.7],~   [1,~1.0700001,~1.14,~\\dots,~1.5599999,~1.63,~1.7],~   \\dots,~   [1,~1.0700001,~1.14,~\\dots,~1.5599999,~1.63,~1.7],~   [1,~1.0700001,~1.14,~\\dots,~1.5599999,~1.63,~1.7],~   [1,~1.0700001,~1.14,~\\dots,~1.5599999,~1.63,~1.7]]] \\; \\mathrm{\\mu m}$  <p>Instead of seeing the grid of all points, you may want to see only the unique values of the grid which you can do using</p> In\u00a0[11]: Copied! <pre>p.wavelength1d\n</pre> p.wavelength1d Out[11]:  $[1,~1.0700001,~1.14,~1.21,~1.28,~1.35,~1.42,~1.49,~1.5599999,~1.63,~1.7] \\; \\mathrm{\\mu m}$  <p>Otherwise you may care about the midpoint of any of the dimensions, which you can find with</p> In\u00a0[12]: Copied! <pre>p.wavelength0d\n</pre> p.wavelength0d Out[12]:  $1.35 \\; \\mathrm{\\mu m}$  <p>Let's take a look at the PSF</p> In\u00a0[13]: Copied! <pre>p.plot_spatial()\n</pre> p.plot_spatial() <p>This plot shows the spatial changes for the PSF model. You can see the PSF changes significantly as you move across the detector. Let's look at the wavelength dependence.</p> In\u00a0[14]: Copied! <pre>p.plot_spectral()\n</pre> p.plot_spectral() <p>The PSF also changes in wavelength. This is expected. Let's calculate a PSF at a particular position.</p> <p>Note</p> <p>         Note that the pixel position is with respect to the center of the detector.     </p> In\u00a0[15]: Copied! <pre>p.psf(row=100, column=-40, wavelength=1.3)\n</pre> p.psf(row=100, column=-40, wavelength=1.3) Out[15]: <pre>array([[1.1413812e-08, 1.1438539e-08, 1.1504300e-08, ..., 5.7991909e-09,\n        6.2154766e-09, 6.5049841e-09],\n       [1.1382001e-08, 1.1421678e-08, 1.1517125e-08, ..., 5.8108842e-09,\n        6.1768644e-09, 6.4395862e-09],\n       [1.1261743e-08, 1.1338595e-08, 1.1472190e-08, ..., 5.8173795e-09,\n        6.1129120e-09, 6.3256094e-09],\n       ...,\n       [6.2430208e-09, 6.1320433e-09, 6.0301097e-09, ..., 6.4347923e-09,\n        6.3768613e-09, 6.3250787e-09],\n       [6.2202008e-09, 6.1017147e-09, 5.9619816e-09, ..., 6.2192496e-09,\n        6.1606786e-09, 6.1071561e-09],\n       [6.1357048e-09, 6.0286069e-09, 5.8950640e-09, ..., 6.0526073e-09,\n        6.0041985e-09, 5.9568013e-09]], dtype=float32)</pre> <p>This matrix is the PSF at the input positions. Note that here <code>row</code> and <code>column</code> are position on the detector. The image of the PSF also has an extent in row and column, you can access that with <code>psf_row</code> and <code>psf_column</code></p> In\u00a0[16]: Copied! <pre>p.psf_row\n</pre> p.psf_row Out[16]:  $[-50.464665,~-50.267922,~-50.071179,~\\dots,~49.677692,~49.874435,~50.071179] \\; \\mathrm{pix}$  <p>We can plot this</p> In\u00a0[17]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n</pre> import numpy as np import matplotlib.pyplot as plt In\u00a0[18]: Copied! <pre>fig, ax = plt.subplots(figsize=(4, 4))\nax.pcolormesh(p.psf_column.value, p.psf_row.value, p.psf(row=100, column=-40, wavelength=1.3), vmin=0, vmax=0.001)\nax.set(xlabel='$\\delta$ Column [pixel]', ylabel='$\\delta$ Row [pixel]');\n</pre> fig, ax = plt.subplots(figsize=(4, 4)) ax.pcolormesh(p.psf_column.value, p.psf_row.value, p.psf(row=100, column=-40, wavelength=1.3), vmin=0, vmax=0.001) ax.set(xlabel='$\\delta$ Column [pixel]', ylabel='$\\delta$ Row [pixel]'); <p>This looks good. This PSF model is at a higher resolution than the pixel grid. We have the x and y axes as $\\delta$ Column and $\\delta$ Row because this is the position with respect to the center of the target. We might want instead to find the PRF; the Pixel Response function. This is the PSF integrated across the pixels of the detector.</p> In\u00a0[19]: Copied! <pre>p.prf(row=10, column=1, wavelength=1.3)\n</pre> p.prf(row=10, column=1, wavelength=1.3) Out[19]: <pre>(array([-42, -41, -40, -39, -38, -37, -36, -35, -34, -33, -32, -31, -30,\n        -29, -28, -27, -26, -25, -24, -23, -22, -21, -20, -19, -18, -17,\n        -16, -15, -14, -13, -12, -11, -10,  -9,  -8,  -7,  -6,  -5,  -4,\n         -3,  -2,  -1,   0,   1,   2,   3,   4,   5,   6,   7,   8,   9,\n         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,  20,  21,  22,\n         23,  24,  25,  26,  27,  28,  29,  30,  31,  32,  33,  34,  35,\n         36,  37,  38,  39,  40,  41,  42,  43,  44,  45,  46,  47,  48,\n         49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,\n         62]),\n array([-51, -50, -49, -48, -47, -46, -45, -44, -43, -42, -41, -40, -39,\n        -38, -37, -36, -35, -34, -33, -32, -31, -30, -29, -28, -27, -26,\n        -25, -24, -23, -22, -21, -20, -19, -18, -17, -16, -15, -14, -13,\n        -12, -11, -10,  -9,  -8,  -7,  -6,  -5,  -4,  -3,  -2,  -1,   0,\n          1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,\n         14,  15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,\n         27,  28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,\n         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,  50,  51,  52,\n         53]),\n array([[0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n         0.00000000e+00, 0.00000000e+00, 0.00000000e+00],\n        [0.00000000e+00, 2.89177905e-07, 2.86015506e-07, ...,\n         1.31696765e-07, 0.00000000e+00, 0.00000000e+00],\n        [0.00000000e+00, 2.39206088e-07, 2.88983358e-07, ...,\n         1.05896504e-07, 0.00000000e+00, 0.00000000e+00],\n        ...,\n        [0.00000000e+00, 1.91942789e-07, 1.92561089e-07, ...,\n         1.61444021e-07, 0.00000000e+00, 0.00000000e+00],\n        [0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n         0.00000000e+00, 0.00000000e+00, 0.00000000e+00],\n        [0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ...,\n         0.00000000e+00, 0.00000000e+00, 0.00000000e+00]], dtype=float32))</pre> <p>This has now returned the row and column position on the detector, as well as the image. Let's plot it</p> In\u00a0[20]: Copied! <pre>r, c, ar = p.prf(row=100, column=-40, wavelength=1.3)\n</pre> r, c, ar = p.prf(row=100, column=-40, wavelength=1.3) In\u00a0[21]: Copied! <pre>fig, ax = plt.subplots(figsize=(4, 4))\nax.pcolormesh(c, r, ar, vmin=0, vmax=0.001)\nax.set(xlabel='Column [pixel]', ylabel='Row [pixel]');\n</pre> fig, ax = plt.subplots(figsize=(4, 4)) ax.pcolormesh(c, r, ar, vmin=0, vmax=0.001) ax.set(xlabel='Column [pixel]', ylabel='Row [pixel]'); <p>This is now at the pixel resolution.</p> <p>Large numbers of dimensions make calculating the PRF or PSF model slower, because we have to integrate over many dimensions. We might want to calculate the PRF in a small region of the detector, in which case we might want to freeze certain dimensions. We can do that here</p> In\u00a0[22]: Copied! <pre>p = PSF.from_name(\"NIRDA\").freeze_dimension(row=0, column=0)\n</pre> p = PSF.from_name(\"NIRDA\").freeze_dimension(row=0, column=0) <p>Here we have loaded the NIR PSF and \"frozen\" the row and column dimensions to 0.</p> In\u00a0[23]: Copied! <pre>p\n</pre> p Out[23]: <pre>1D PSF Model [wavelength] (Frozen: row: 0.000, column: 0.000)</pre> <p>This is now a 1D model, and is only a function of wavelength. This should be faster to calculate the PRF.</p> <p>Similarly, you can freeze the PSF as a function of wavelength</p> In\u00a0[24]: Copied! <pre>p = PSF.from_name(\"NIRDA\").freeze_dimension(wavelength=1.3)\n</pre> p = PSF.from_name(\"NIRDA\").freeze_dimension(wavelength=1.3) In\u00a0[25]: Copied! <pre>p\n</pre> p Out[25]: <pre>2D PSF Model [row, column] (Frozen: wavelength: 1.300)</pre> <p>Using Units</p> <p>         `pandorapsf` uses units to ensure that wavelength and position are correct. If you pass in unitless values as I am doing above, `pandorapsf` will assume they are the units of those axes. To be safe, you should consider passing in values with units, for example see below.     </p> In\u00a0[26]: Copied! <pre>import astropy.units as u\np = PSF.from_name(\"NIRDA\").freeze_dimension(wavelength=1300*u.nm)\n</pre> import astropy.units as u p = PSF.from_name(\"NIRDA\").freeze_dimension(wavelength=1300*u.nm) In\u00a0[27]: Copied! <pre>p\n</pre> p Out[27]: <pre>2D PSF Model [row, column] (Frozen: wavelength: 1300.000 nm)</pre> In\u00a0[28]: Copied! <pre>r, c, ar, dar1, dar2 = p.prf(row=100, column=-40, gradients=True)\n</pre> r, c, ar, dar1, dar2 = p.prf(row=100, column=-40, gradients=True) In\u00a0[29]: Copied! <pre>fig, ax = plt.subplots(1, 3, figsize=(12, 3))\nax[0].pcolormesh(c, r, ar, vmin=0, vmax=0.001)\nax[1].pcolormesh(c, r, dar1, vmin=-0.001, vmax=0.001, cmap='coolwarm')\nax[2].pcolormesh(c, r, dar2, vmin=-0.001, vmax=0.001, cmap='coolwarm')\nax[0].set(xlabel='Column [pixel]', ylabel='Row [pixel]', title='Data')\nax[1].set(xlabel='Column [pixel]', ylabel='Row [pixel]', title='Gradient dimension 1')\nax[2].set(xlabel='Column [pixel]', ylabel='Row [pixel]', title='Gradient dimension 2');\n</pre> fig, ax = plt.subplots(1, 3, figsize=(12, 3)) ax[0].pcolormesh(c, r, ar, vmin=0, vmax=0.001) ax[1].pcolormesh(c, r, dar1, vmin=-0.001, vmax=0.001, cmap='coolwarm') ax[2].pcolormesh(c, r, dar2, vmin=-0.001, vmax=0.001, cmap='coolwarm') ax[0].set(xlabel='Column [pixel]', ylabel='Row [pixel]', title='Data') ax[1].set(xlabel='Column [pixel]', ylabel='Row [pixel]', title='Gradient dimension 1') ax[2].set(xlabel='Column [pixel]', ylabel='Row [pixel]', title='Gradient dimension 2'); <p>These gradients are useful for approximating small shifts in position.</p> <p>You can use the <code>scale</code> parameter to increase or decrease the effective size of the PSF. This scales the <code>psf_row</code> and <code>psf_column</code> attributes so that the resultant PRF is larger or smaller on the detector.</p> In\u00a0[30]: Copied! <pre>p1 = PSF.from_name(\"NIRDA\", scale=1)\np2 = PSF.from_name(\"NIRDA\", scale=2)\n</pre> p1 = PSF.from_name(\"NIRDA\", scale=1) p2 = PSF.from_name(\"NIRDA\", scale=2) In\u00a0[31]: Copied! <pre>fig, ax = plt.subplots(1, 2, figsize=(8, 4), sharex=True, sharey=True)\n\nr, c, ar = p1.prf(row=100, column=-40, wavelength=1.3)\nax[0].scatter(-40, 100, c='r', zorder=10)\nax[0].pcolormesh(c, r, ar, vmin=0, vmax=0.001)\nax[0].set(xlabel='Column [pixel]', ylabel='Row [pixel]', title='Scale=1');\n\nr, c, ar = p2.prf(row=100, column=-40, wavelength=1.3)\nax[1].pcolormesh(c, r, ar, vmin=0, vmax=0.001)\nax[1].scatter(-40, 100, c='r', zorder=10)\nax[1].set(xlabel='Column [pixel]', ylabel='Row [pixel]', title='Scale=2');\n</pre> fig, ax = plt.subplots(1, 2, figsize=(8, 4), sharex=True, sharey=True)  r, c, ar = p1.prf(row=100, column=-40, wavelength=1.3) ax[0].scatter(-40, 100, c='r', zorder=10) ax[0].pcolormesh(c, r, ar, vmin=0, vmax=0.001) ax[0].set(xlabel='Column [pixel]', ylabel='Row [pixel]', title='Scale=1');  r, c, ar = p2.prf(row=100, column=-40, wavelength=1.3) ax[1].pcolormesh(c, r, ar, vmin=0, vmax=0.001) ax[1].scatter(-40, 100, c='r', zorder=10) ax[1].set(xlabel='Column [pixel]', ylabel='Row [pixel]', title='Scale=2'); In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"example-psf/#psf-class-example","title":"PSF Class Example\u00b6","text":"<p>The <code>PSF</code> class is a way to work with the Point Spread Function of one or many targets.</p>"},{"location":"example-psf/#gradients","title":"Gradients\u00b6","text":"<p>You may find you need to use gradients of the PSF or PRF, these are available to you</p>"},{"location":"example-psf/#scaling-psfs","title":"Scaling PSFs\u00b6","text":""},{"location":"example-roiscene/","title":"ROIScene Class Example","text":"In\u00a0[1]: Copied! <pre>from pandorapsf import ROIScene, PSF\nimport matplotlib.pyplot as plt\nimport numpy as np\n</pre> from pandorapsf import ROIScene, PSF import matplotlib.pyplot as plt import numpy as np In\u00a0[2]: Copied! <pre>p = PSF.from_name(\"VISDA\")\n</pre> p = PSF.from_name(\"VISDA\") In\u00a0[3]: Copied! <pre>p\n</pre> p Out[3]: <pre>2D PSF Model [row, column]</pre> In\u00a0[4]: Copied! <pre>nROIs = 9\nROI_size = (50, 51)\nROI_corners = [(int(r), int(c)) for r, c in np.random.uniform(-800, 800, (2, 9)).T]\n</pre> nROIs = 9 ROI_size = (50, 51) ROI_corners = [(int(r), int(c)) for r, c in np.random.uniform(-800, 800, (2, 9)).T] <p>We'll need some locations at which to place some PSFs. We can randomly generate some locations. Here I am generating sources across the entire region of the detector.</p> In\u00a0[5]: Copied! <pre>import numpy as np\nnsources = 30\nr = np.hstack([np.random.uniform(corner[0] - 20, corner[0] + ROI_size[0] + 20, (nsources)) for corner in ROI_corners])\nc = np.hstack([np.random.uniform(corner[1] - 20, corner[1] + ROI_size[1] + 20, (nsources)) for corner in ROI_corners])\n</pre> import numpy as np nsources = 30 r = np.hstack([np.random.uniform(corner[0] - 20, corner[0] + ROI_size[0] + 20, (nsources)) for corner in ROI_corners]) c = np.hstack([np.random.uniform(corner[1] - 20, corner[1] + ROI_size[1] + 20, (nsources)) for corner in ROI_corners]) <p>Below I show a plot of where the sources fall and the ROIs we've randomly generated.</p> In\u00a0[6]: Copied! <pre>fig, ax = plt.subplots(figsize=(6, 6))\nplt.scatter(c, r, s=1, c='k')\n[ax.plot([corner[1], corner[1] + ROI_size[1], corner[1] + ROI_size[1], corner[1], corner[1]], [corner[0], corner[0], corner[0] + ROI_size[0], corner[0] + ROI_size[0], corner[0]], c='r') for corner in ROI_corners] \nax.set(xlim=(-1024, 1024), ylim=(-1024, 1024), xlabel='Column [pixel]', ylabel='Row [pixel]', title='Source Positions');\n</pre> fig, ax = plt.subplots(figsize=(6, 6)) plt.scatter(c, r, s=1, c='k') [ax.plot([corner[1], corner[1] + ROI_size[1], corner[1] + ROI_size[1], corner[1], corner[1]], [corner[0], corner[0], corner[0] + ROI_size[0], corner[0] + ROI_size[0], corner[0]], c='r') for corner in ROI_corners]  ax.set(xlim=(-1024, 1024), ylim=(-1024, 1024), xlabel='Column [pixel]', ylabel='Row [pixel]', title='Source Positions'); <p>Note</p> <p>         I have included sources close to the ROIs with some buffer around them. If we include too many sources this will be slow to calculate. If we do not include a buffer we could miss sources that have flux from PSF wings fall into the ROI. We also need nearby sources that may move into the ROI if there is significant motion. Use your judgement to find a balance between including sources and keeping the number of sources low.     </p> <p>We can now build the scene object</p> In\u00a0[7]: Copied! <pre>s = ROIScene(locations=np.asarray([r, c]).T,\n             psf=p,\n             shape=(2048, 2048),\n             corner=(-1024, -1024), \n             nROIs=nROIs,\n             ROI_size=ROI_size,\n             ROI_corners=ROI_corners\n            )\n</pre> s = ROIScene(locations=np.asarray([r, c]).T,              psf=p,              shape=(2048, 2048),              corner=(-1024, -1024),               nROIs=nROIs,              ROI_size=ROI_size,              ROI_corners=ROI_corners             ) <p>We've now created our ROIscene object. We can use the <code>model</code> class method to model an image. We'll have to pass in some fluxes to model, we can make those randomly.</p> In\u00a0[8]: Copied! <pre>flux = 10**np.random.normal(0, 0.4, s.ntargets)\n</pre> flux = 10**np.random.normal(0, 0.4, s.ntargets) In\u00a0[9]: Copied! <pre>images = s.model(flux**0)\n</pre> images = s.model(flux**0) <p>This has modeled an image stack for us. We expect one time (we only passed a single flux value) 9 ROIs, and the ROI image shape..</p> In\u00a0[10]: Copied! <pre>images.shape\n</pre> images.shape Out[10]: <pre>(9, 1, 50, 51)</pre> <p>Here we have the images for each ROI, then each time, as a function of row then column. We could optionally pass in more times, and position changes as we have done in the <code>Scene</code> class.</p> In\u00a0[11]: Copied! <pre>ntimes = 100\nflux = 10**np.random.normal(0, 0.4, (s.ntargets))[:, None] * np.ones(ntimes)\ndelta_position = np.random.uniform(-6, 6, (2, ntimes))\n</pre> ntimes = 100 flux = 10**np.random.normal(0, 0.4, (s.ntargets))[:, None] * np.ones(ntimes) delta_position = np.random.uniform(-6, 6, (2, ntimes)) In\u00a0[12]: Copied! <pre>images = s.model(flux, delta_pos=delta_position)\n</pre> images = s.model(flux, delta_pos=delta_position) <pre>Modeling Pixel Positions: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 72/72 [00:08&lt;00:00,  8.44it/s]\n</pre> In\u00a0[13]: Copied! <pre>images.shape\n</pre> images.shape Out[13]: <pre>(9, 100, 50, 51)</pre> <p>Now we have 100 time samples for 9 ROIs. Let's take a look at the images. We'll look at the first 3 images of the first ROI.</p> In\u00a0[14]: Copied! <pre>fig, ax = plt.subplots(1, 3, figsize=(12, 4))\nax[0].imshow(images[0, 0], vmin=0, vmax=0.01)\nax[1].imshow(images[0, 1], vmin=0, vmax=0.01)\nax[2].imshow(images[0, 2], vmin=0, vmax=0.01)\nax[0].set(xlabel='Column [pixel]', ylabel='Row [pixel]', title='Example Image Position 1');\nax[1].set(xlabel='Column [pixel]', ylabel='Row [pixel]', title='Example Image Position 2');\nax[2].set(xlabel='Column [pixel]', ylabel='Row [pixel]', title='Example Image Position 3');\n</pre> fig, ax = plt.subplots(1, 3, figsize=(12, 4)) ax[0].imshow(images[0, 0], vmin=0, vmax=0.01) ax[1].imshow(images[0, 1], vmin=0, vmax=0.01) ax[2].imshow(images[0, 2], vmin=0, vmax=0.01) ax[0].set(xlabel='Column [pixel]', ylabel='Row [pixel]', title='Example Image Position 1'); ax[1].set(xlabel='Column [pixel]', ylabel='Row [pixel]', title='Example Image Position 2'); ax[2].set(xlabel='Column [pixel]', ylabel='Row [pixel]', title='Example Image Position 3'); <p>You can see the image is the same but shifted, since we've included a delta position parameter.</p>"},{"location":"example-roiscene/#roiscene-class-example","title":"ROIScene Class Example\u00b6","text":"<p>In Pandora we are interested in Regions of Interest around certain stars. While the <code>Scene</code> class is useful for modeling Full Frame Images, the <code>ROIScene</code> class is useful for modeling cut outs of larger scenes. Regions of interest are special cases.</p>"},{"location":"example-scene/","title":"Scene Class Example","text":"In\u00a0[1]: Copied! <pre>from pandorapsf import Scene, PSF\n</pre> from pandorapsf import Scene, PSF In\u00a0[2]: Copied! <pre>p = PSF.from_name(\"VISDA\")\n</pre> p = PSF.from_name(\"VISDA\") In\u00a0[3]: Copied! <pre>p\n</pre> p Out[3]: <pre>2D PSF Model [row, column]</pre> <p>We'll need some locations at which to place some PSFs. We can randomly generate some locations</p> In\u00a0[4]: Copied! <pre>import numpy as np\nnsources = 1280\nr, c = np.random.uniform(-1024, 1024, (2, nsources))\n</pre> import numpy as np nsources = 1280 r, c = np.random.uniform(-1024, 1024, (2, nsources)) <p>Note</p> <p>         Note here that the source positions are normalized to zero. This is because in `pandorapsf` row=0 column=0 is the middle of the detector.      </p> In\u00a0[5]: Copied! <pre>s = Scene(locations=np.asarray([r, c]).T, psf=p, shape=(2048, 2048), corner=(-1024, -1024))\n</pre> s = Scene(locations=np.asarray([r, c]).T, psf=p, shape=(2048, 2048), corner=(-1024, -1024)) In\u00a0[6]: Copied! <pre>s\n</pre> s Out[6]: <pre>Scene Object [2D PSF Model [row, column]] Detector Size: (2048, 2048), ntargets: 1280</pre> <p>We've now created our scene object. We can use the <code>model</code> class method to model an image. We'll have to pass in some fluxes to model, we can make those randomly.</p> In\u00a0[7]: Copied! <pre>flux = 10**np.random.normal(0, 0.4, nsources)\n</pre> flux = 10**np.random.normal(0, 0.4, nsources) In\u00a0[8]: Copied! <pre>images = s.model(flux)\n</pre> images = s.model(flux) <p>This has modeled an image stack for us</p> In\u00a0[9]: Copied! <pre>images.shape\n</pre> images.shape Out[9]: <pre>(1, 2048, 2048)</pre> <p>We've only passed in a single flux, so this has given us one image in time. We could create flux at many times and pass those in to create more images.</p> In\u00a0[10]: Copied! <pre>ntimes = 10\nflux = 10**np.random.normal(0, 0.4, (nsources, ntimes))\n</pre> ntimes = 10 flux = 10**np.random.normal(0, 0.4, (nsources, ntimes)) In\u00a0[11]: Copied! <pre>images = s.model(flux)\n</pre> images = s.model(flux) In\u00a0[12]: Copied! <pre>images.shape\n</pre> images.shape Out[12]: <pre>(10, 2048, 2048)</pre> <p>Let's plot one of the images to see what it loks like</p> In\u00a0[13]: Copied! <pre>import matplotlib.pyplot as plt\n</pre> import matplotlib.pyplot as plt In\u00a0[14]: Copied! <pre>fig, ax = plt.subplots(figsize=(6, 6))\nax.imshow(images[0], vmin=0, vmax=0.001)\nax.set(xlabel='Column [pixel]', ylabel='Row [pixel]', title='Example Image');\n</pre> fig, ax = plt.subplots(figsize=(6, 6)) ax.imshow(images[0], vmin=0, vmax=0.001) ax.set(xlabel='Column [pixel]', ylabel='Row [pixel]', title='Example Image'); <p>We may want to also change the position of the scene as a function of time.</p> In\u00a0[15]: Copied! <pre>ntimes = 3\nflux = 10**np.random.normal(0, 0.4, (nsources, ntimes))\ndelta_position = np.random.uniform(-300, 300, (2, ntimes))\n</pre> ntimes = 3 flux = 10**np.random.normal(0, 0.4, (nsources, ntimes)) delta_position = np.random.uniform(-300, 300, (2, ntimes)) In\u00a0[16]: Copied! <pre>images = s.model(flux, delta_pos=delta_position)\n</pre> images = s.model(flux, delta_pos=delta_position) <pre>Modeling Pixel Positions: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3/3 [00:01&lt;00:00,  2.61it/s]\n</pre> <p>Including a delta position within the scene model enables the scene to be moved in each time step. This uses gradients to approximate the PRF after a subpixel shift.</p> In\u00a0[17]: Copied! <pre>fig, ax = plt.subplots(1, 3, figsize=(12, 4))\nax[0].imshow(images[0], vmin=0, vmax=0.001)\nax[0].scatter(1024 + delta_position[1, 0], 1024 + delta_position[0, 0], c='r')\nax[1].imshow(images[1], vmin=0, vmax=0.001)\nax[1].scatter(1024 + delta_position[1, 1], 1024 + delta_position[0, 1], c='r')\nax[2].imshow(images[2], vmin=0, vmax=0.001)\nax[2].scatter(1024 + delta_position[1, 2], 1024 + delta_position[0, 2], c='r')\nax[0].set(xlabel='Column [pixel]', ylabel='Row [pixel]', title='Example Image Position 1');\nax[1].set(xlabel='Column [pixel]', ylabel='Row [pixel]', title='Example Image Position 2');\nax[2].set(xlabel='Column [pixel]', ylabel='Row [pixel]', title='Example Image Position 3');\n</pre> fig, ax = plt.subplots(1, 3, figsize=(12, 4)) ax[0].imshow(images[0], vmin=0, vmax=0.001) ax[0].scatter(1024 + delta_position[1, 0], 1024 + delta_position[0, 0], c='r') ax[1].imshow(images[1], vmin=0, vmax=0.001) ax[1].scatter(1024 + delta_position[1, 1], 1024 + delta_position[0, 1], c='r') ax[2].imshow(images[2], vmin=0, vmax=0.001) ax[2].scatter(1024 + delta_position[1, 2], 1024 + delta_position[0, 2], c='r') ax[0].set(xlabel='Column [pixel]', ylabel='Row [pixel]', title='Example Image Position 1'); ax[1].set(xlabel='Column [pixel]', ylabel='Row [pixel]', title='Example Image Position 2'); ax[2].set(xlabel='Column [pixel]', ylabel='Row [pixel]', title='Example Image Position 3'); <p>Adding in position shifts will slow down the modeling of the image.</p> In\u00a0[18]: Copied! <pre>nsources = 30\nr, c = np.random.uniform(-50, 50, (2, nsources))\nflux = 10**np.random.normal(0, 0.4, nsources)\n</pre> nsources = 30 r, c = np.random.uniform(-50, 50, (2, nsources)) flux = 10**np.random.normal(0, 0.4, nsources) In\u00a0[19]: Copied! <pre>scale = 1\np = PSF.from_name(\"VISDA\", scale=scale)\ns = Scene(locations=np.asarray([r, c]).T,\n          psf=p,\n          shape=(100, 101),\n          corner=(-50, -50), \n          scale=scale)\n</pre> scale = 1 p = PSF.from_name(\"VISDA\", scale=scale) s = Scene(locations=np.asarray([r, c]).T,           psf=p,           shape=(100, 101),           corner=(-50, -50),            scale=scale) <p>Here I have created a simulation of 100 x 101 size image, with <code>scale=1</code>. Let's look at the image this creates</p> In\u00a0[20]: Copied! <pre>fig, ax = plt.subplots(figsize=(6, 6))\nax.imshow(s.model(flux)[0], vmin=0, vmax=0.01)\nax.set(xlabel='Column [pixel]', ylabel='Row [pixel]', title='Example Image');\n</pre> fig, ax = plt.subplots(figsize=(6, 6)) ax.imshow(s.model(flux)[0], vmin=0, vmax=0.01) ax.set(xlabel='Column [pixel]', ylabel='Row [pixel]', title='Example Image'); <p>Here we have used a PRF evaluated at the pixel resolution. Let's double the scale</p> In\u00a0[21]: Copied! <pre>scale = 2\np = PSF.from_name(\"VISDA\", scale=scale)\ns = Scene(locations=np.asarray([r, c]).T,\n          psf=p,\n          shape=(100, 101),\n          corner=(-50, -50), \n          scale=scale)\n</pre> scale = 2 p = PSF.from_name(\"VISDA\", scale=scale) s = Scene(locations=np.asarray([r, c]).T,           psf=p,           shape=(100, 101),           corner=(-50, -50),            scale=scale) In\u00a0[22]: Copied! <pre>fig, ax = plt.subplots(figsize=(6, 6))\nax.imshow(s.model(flux)[0], vmin=0, vmax=0.01)\nax.set(xlabel='Column [pixel]', ylabel='Row [pixel]', title='Example Image');\n</pre> fig, ax = plt.subplots(figsize=(6, 6)) ax.imshow(s.model(flux)[0], vmin=0, vmax=0.01) ax.set(xlabel='Column [pixel]', ylabel='Row [pixel]', title='Example Image'); <p>This has now created an image with 2x the dimensions, with a PSF that is 2x wider. This is slower to evaluate, but is higher fidelity. We may want to calculate the image in this higher resolution space and then downsample back to the image space, which we can do using the <code>downsample</code> keyword inside <code>model</code>.</p> In\u00a0[23]: Copied! <pre>fig, ax = plt.subplots(figsize=(6, 6))\nax.imshow(s.model(flux, downsample=True)[0], vmin=0, vmax=0.01)\nax.set(xlabel='Column [pixel]', ylabel='Row [pixel]', title='Example Image');\n</pre> fig, ax = plt.subplots(figsize=(6, 6)) ax.imshow(s.model(flux, downsample=True)[0], vmin=0, vmax=0.01) ax.set(xlabel='Column [pixel]', ylabel='Row [pixel]', title='Example Image'); <p>This image looks a lot like the first, but is a more accurate model of the scene. We can time the functions to see how much of a slow down we suffer for this higher resolution</p> In\u00a0[24]: Copied! <pre>scale = 1\np = PSF.from_name(\"VISDA\", scale=scale)\ns_lowres = Scene(locations=np.asarray([r, c]).T,\n          psf=p,\n          shape=(100, 101),\n          corner=(-50, -50), \n          scale=scale)\n\nscale = 2\np = PSF.from_name(\"VISDA\", scale=scale)\ns_highres = Scene(locations=np.asarray([r, c]).T,\n          psf=p,\n          shape=(100, 101),\n          corner=(-50, -50), \n          scale=scale)\n</pre> scale = 1 p = PSF.from_name(\"VISDA\", scale=scale) s_lowres = Scene(locations=np.asarray([r, c]).T,           psf=p,           shape=(100, 101),           corner=(-50, -50),            scale=scale)  scale = 2 p = PSF.from_name(\"VISDA\", scale=scale) s_highres = Scene(locations=np.asarray([r, c]).T,           psf=p,           shape=(100, 101),           corner=(-50, -50),            scale=scale) In\u00a0[25]: Copied! <pre>%%timeit\ns_lowres.model(flux)\n</pre> %%timeit s_lowres.model(flux) <pre>70.4 \u00b5s \u00b1 3.02 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n</pre> In\u00a0[26]: Copied! <pre>%%timeit\ns_highres.model(flux, downsample=True)\n</pre> %%timeit s_highres.model(flux, downsample=True) <pre>406 \u00b5s \u00b1 8.15 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1,000 loops each)\n</pre> <p>You should decide based on your application whether you are interested in speed or accuracy.</p>"},{"location":"example-scene/#scene-class-example","title":"Scene Class Example\u00b6","text":"<p>The <code>Scene</code> class is a way to work with multiple targets near each other in a \"Scene\". You will need to supply the scene with the PSF model you'd like to use.</p>"},{"location":"example-scene/#making-higher-fidelity-simulations","title":"Making higher fidelity simulations\u00b6","text":"<p>There is a trade in simulating images between speed of computation and accuracy of simulations.</p> <p>You are able to tune the the fidelity of the simulations using the <code>scale</code> parameter.</p>"},{"location":"example-tracescene/","title":"TraceScene Class Example","text":"In\u00a0[1]: Copied! <pre>from pandorapsf import TraceScene, PSF\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandorasat as ps\nimport astropy.units as u\n</pre> from pandorapsf import TraceScene, PSF import matplotlib.pyplot as plt import numpy as np import pandorasat as ps import astropy.units as u In\u00a0[2]: Copied! <pre>p = PSF.from_name(\"NIRDA\").freeze_dimension(row=0, column=0)\n</pre> p = PSF.from_name(\"NIRDA\").freeze_dimension(row=0, column=0) In\u00a0[3]: Copied! <pre>p\n</pre> p Out[3]: <pre>1D PSF Model [wavelength] (Frozen: row: 0.000, column: 0.000)</pre> <p>This PSF object is a function of wavelength. We can look at the trace sensitivity as a function of pixel and wavelength.</p> In\u00a0[4]: Copied! <pre>fig, ax = plt.subplots()\nim = ax.scatter(p.trace_pixel.value, p.trace_wavelength.value, c=p.trace_sensitivity.value, cmap='coolwarm_r', vmin=0, vmax=p.trace_sensitivity.max().value, s=1)\ncbar = plt.colorbar(im, ax=ax)\ncbar.set_label(f\"Sensitivity [{p.trace_sensitivity.unit.to_string('latex')}]\")\nax.set(ylabel='Wavelength [$\\mu$m]', xlabel='Pixel Position', title='Sensitivity of NIR Detector');\n</pre> fig, ax = plt.subplots() im = ax.scatter(p.trace_pixel.value, p.trace_wavelength.value, c=p.trace_sensitivity.value, cmap='coolwarm_r', vmin=0, vmax=p.trace_sensitivity.max().value, s=1) cbar = plt.colorbar(im, ax=ax) cbar.set_label(f\"Sensitivity [{p.trace_sensitivity.unit.to_string('latex')}]\") ax.set(ylabel='Wavelength [$\\mu$m]', xlabel='Pixel Position', title='Sensitivity of NIR Detector'); <p>This looks like what we expect. This information is baked into the PSF object. This will be used by the <code>TraceScene</code> class. Let's build one</p> In\u00a0[5]: Copied! <pre>ts = TraceScene(locations=np.asarray([(200, 40)]), psf=p, shape=(400, 80), corner=(0, 0))\n</pre> ts = TraceScene(locations=np.asarray([(200, 40)]), psf=p, shape=(400, 80), corner=(0, 0)) In\u00a0[6]: Copied! <pre>ts\n</pre> ts Out[6]: <pre>TraceScene Object [1D PSF Model [wavelength] (Frozen: row: 0.000, column: 0.000)]</pre> <p>Here I've made a <code>TraceScene</code> object where the source is located at (200, 40) in the image. The default wavelength spacing for <code>TraceScene</code> is one PSF element per quarter pixel. You can change the grid it is evaluated at using the <code>wavelenth</code> keyword argument. Let's see how many wavelength elements there are in the <code>TraceScene</code></p> In\u00a0[7]: Copied! <pre>ts.nwav\n</pre> ts.nwav Out[7]: <pre>880</pre> In\u00a0[8]: Copied! <pre>ts.wavelength\n</pre> ts.wavelength Out[8]:  $[0.84809537,~0.84852296,~0.84895055,~\\dots,~1.7093922,~1.711102,~1.7128159] \\; \\mathrm{\\mu m}$  <p>There are many hundreds of elements in this default. This makes the <code>TraceScene</code> object slower to calculate than if it had a lower wavelength resolution.</p> <p>We need a spectrum to create an image. We can do this using <code>pandorasat</code>'s SED function, which will return the SED of a target of given effective temperature and magnitude.</p> In\u00a0[9]: Copied! <pre>target_wavelength, target_spectrum = ps.utils.SED(teff=5777, jmag=13)\n</pre> target_wavelength, target_spectrum = ps.utils.SED(teff=5777, jmag=13) In\u00a0[10]: Copied! <pre>fig, ax = plt.subplots()\nax.plot(target_wavelength, target_spectrum, c='k')\nax.set(xlabel='Wavelength [nm]', ylabel=f\"Flux [{target_spectrum.unit.to_string('latex')}]\", title='Example Target Spectrum');\n</pre> fig, ax = plt.subplots() ax.plot(target_wavelength, target_spectrum, c='k') ax.set(xlabel='Wavelength [nm]', ylabel=f\"Flux [{target_spectrum.unit.to_string('latex')}]\", title='Example Target Spectrum'); <p>This is at a different resolution and wavelength range than the <code>TraceScene</code> object. We need to integrate this spectrum onto the wavelength grid of the <code>TraceScene</code> object. Let's do that</p> In\u00a0[11]: Copied! <pre>integrated_spec = ts.integrate_spectrum(*ps.utils.SED(teff=5777, jmag=13))\n</pre> integrated_spec = ts.integrate_spectrum(*ps.utils.SED(teff=5777, jmag=13)) In\u00a0[12]: Copied! <pre>fig, ax = plt.subplots()\nax.plot(ts.wavelength, integrated_spec, c='k')\nax.set(xlabel='Wavelength [$\\mu$m]', ylabel='Flux [e$^{-1}$/s]', title='Example Target Spectrum');\n</pre> fig, ax = plt.subplots() ax.plot(ts.wavelength, integrated_spec, c='k') ax.set(xlabel='Wavelength [$\\mu$m]', ylabel='Flux [e$^{-1}$/s]', title='Example Target Spectrum'); <p>This is now the integrated spectrum in each wavelength element of the trace scene, accounting for Pandora's sensitivity and the NIR detector QE. Let's make this into an image on the detector.</p> In\u00a0[13]: Copied! <pre>images = ts.model(spectra=integrated_spec)\n</pre> images = ts.model(spectra=integrated_spec) <p>This contains one image for a single time stamp. Let's plot it</p> In\u00a0[14]: Copied! <pre>fig, ax = plt.subplots(figsize=(6, 6))\nax.imshow(images[0].value, vmin=0, vmax=10)\nax.set(xlabel='Column [pixel]', ylabel='Row [pixel]', title='Example Trace');\n</pre> fig, ax = plt.subplots(figsize=(6, 6)) ax.imshow(images[0].value, vmin=0, vmax=10) ax.set(xlabel='Column [pixel]', ylabel='Row [pixel]', title='Example Trace'); <p>This image has units of $e^{-1}/s$. We can then use this image to calculate models of the detector response.</p> <p>Just like other <code>Scene</code> classes this class can be used to create images of traces over time.</p> In\u00a0[15]: Copied! <pre>nt = 10\nimages = ts.model(spectra=integrated_spec[:, None, None] * np.arange(nt))\n</pre> nt = 10 images = ts.model(spectra=integrated_spec[:, None, None] * np.arange(nt)) In\u00a0[16]: Copied! <pre>images.shape\n</pre> images.shape Out[16]: <pre>(10, 400, 80)</pre> <p>Above I've created spectra that get brighter over 10 time stamps. If we plot the central pixel we see the brightness increasing.</p> In\u00a0[17]: Copied! <pre>fig, ax = plt.subplots()\nax.plot(images[:, 200, 40], c='k')\nax.set(xlabel='Frame Number', ylabel='Brightness [$e^{-1}$/s]')\n</pre> fig, ax = plt.subplots() ax.plot(images[:, 200, 40], c='k') ax.set(xlabel='Frame Number', ylabel='Brightness [$e^{-1}$/s]') Out[17]: <pre>[Text(0.5, 0, 'Frame Number'), Text(0, 0.5, 'Brightness [$e^{-1}$/s]')]</pre> <p>You can also create spectra that have motion in them</p> In\u00a0[18]: Copied! <pre>nt = 10\ndelta_position = np.random.uniform(-3, 3, (2, nt)).T\nimages = ts.model(spectra=integrated_spec[:, None, None] * np.ones(nt), delta_pos=delta_position)\n</pre> nt = 10 delta_position = np.random.uniform(-3, 3, (2, nt)).T images = ts.model(spectra=integrated_spec[:, None, None] * np.ones(nt), delta_pos=delta_position) <pre>Modeling Pixel Positions: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 2/2 [00:01&lt;00:00,  1.91it/s]\n</pre> In\u00a0[19]: Copied! <pre>images.shape\n</pre> images.shape Out[19]: <pre>(10, 400, 80)</pre> <p>Now we have 10 images with the same spectrum, but different positions over time. If we difference image the first and last image we see this change.</p> In\u00a0[20]: Copied! <pre>fig, ax = plt.subplots(figsize=(6, 6))\nax.imshow(images[0].value - images[1].value)\nax.set(xlabel='Column [pixel]', ylabel='Row [pixel]', title='First Frame - Last Frame');\n</pre> fig, ax = plt.subplots(figsize=(6, 6)) ax.imshow(images[0].value - images[1].value) ax.set(xlabel='Column [pixel]', ylabel='Row [pixel]', title='First Frame - Last Frame'); <p>You can also create a <code>TraceScene</code> with multiple targets. Let's create a new scene with two targets.</p> In\u00a0[21]: Copied! <pre>ts = TraceScene(locations=np.asarray([(200, 40), (170, 35)]), psf=p, shape=(400, 80), corner=(0, 0))\n</pre> ts = TraceScene(locations=np.asarray([(200, 40), (170, 35)]), psf=p, shape=(400, 80), corner=(0, 0)) <p>Here I'll create spectra for the two targets</p> In\u00a0[22]: Copied! <pre>target1 = ts.integrate_spectrum(*ps.utils.SED(teff=5777, jmag=13))\ntarget2 = ts.integrate_spectrum(*ps.utils.SED(teff=3500, jmag=14))\n</pre> target1 = ts.integrate_spectrum(*ps.utils.SED(teff=5777, jmag=13)) target2 = ts.integrate_spectrum(*ps.utils.SED(teff=3500, jmag=14)) In\u00a0[23]: Copied! <pre>images = ts.model(np.vstack([target1, target2]).T)\n</pre> images = ts.model(np.vstack([target1, target2]).T) In\u00a0[24]: Copied! <pre>images.shape\n</pre> images.shape Out[24]: <pre>(1, 400, 80)</pre> <p>This has created one image, because we only passed in one time stamp of spectra</p> In\u00a0[25]: Copied! <pre>fig, ax = plt.subplots(figsize=(6, 6))\nax.imshow(images[0].value, vmin=0, vmax=10)\nax.set(xlabel='Column [pixel]', ylabel='Row [pixel]', title='Example Trace');\n</pre> fig, ax = plt.subplots(figsize=(6, 6)) ax.imshow(images[0].value, vmin=0, vmax=10) ax.set(xlabel='Column [pixel]', ylabel='Row [pixel]', title='Example Trace'); <p>Now we have two spectra in our image, one for each target. We can similarly change the spectra for each timestamp, or add in motion to the scene.</p> In\u00a0[26]: Copied! <pre>nt = 10\ndelta_position = np.random.uniform(-3, 3, (2, nt)).T\nimages = ts.model(spectra=np.vstack([target1, target2]).T[:, :, None] * np.ones(nt), delta_pos=delta_position)\n</pre> nt = 10 delta_position = np.random.uniform(-3, 3, (2, nt)).T images = ts.model(spectra=np.vstack([target1, target2]).T[:, :, None] * np.ones(nt), delta_pos=delta_position) <pre>Modeling Pixel Positions: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 2/2 [00:02&lt;00:00,  1.00s/it]\n</pre> In\u00a0[27]: Copied! <pre>fig, ax = plt.subplots(figsize=(6, 6))\nax.imshow(images[0].value - images[1].value)\nax.set(xlabel='Column [pixel]', ylabel='Row [pixel]', title='First Frame - Last Frame');\n</pre> fig, ax = plt.subplots(figsize=(6, 6)) ax.imshow(images[0].value - images[1].value) ax.set(xlabel='Column [pixel]', ylabel='Row [pixel]', title='First Frame - Last Frame');"},{"location":"example-tracescene/#tracescene-class-example","title":"TraceScene Class Example\u00b6","text":"<p>The <code>TraceScene</code> class is a way to work with multiple PSFs that make up a spectrum trace. You will need to use a PSF to create a trace from, and inside that PSF object there is the information about the trace pixel, wavelength, and sensitivity distributions.</p>"},{"location":"uploading-new-files/","title":"Uploading new PSF models","text":""},{"location":"uploading-new-files/#uploading-new-psf-models","title":"Uploading new PSF models\u00b6","text":"<p>As we get new models for the PSF, this package requires updating. This notebook shows how to update the PSF files for the package.</p>"},{"location":"uploading-new-files/#updating-with-new-optical-models-from-llnl","title":"Updating with new optical models from LLNL\u00b6","text":"<p>If you have new optical PSF models for the NIR and Visible channel these are usually matlab grids of PSFs as a function of position and wavelength. To update these follow these steps:</p>"},{"location":"uploading-new-files/#build-new-fits-files","title":"Build new fits files\u00b6","text":"<p>The matlab files need to be converted into fits files. Use the function</p> <pre>hdulist = pandorapsf.utils.make_PSF_fits_files(...)\n</pre> <p>Which will return the fits file format for <code>pandorapsf</code>. Look at the docstring for that function to find out how to process the file.</p>"},{"location":"uploading-new-files/#update-the-expected-file-dates-in-the-configuration-file-for-pandorapsf","title":"Update the expected file dates in the configuration file for <code>pandorapsf</code>\u00b6","text":"<p>The config file in <code>pandorapsf</code>'s <code>__init__</code> file has a set of dates, e.g.</p> <pre><code>        \"vis_psf_creation_date\": \"2025-03-28T10:30:27.329441\",\n        \"nir_psf_creation_date\": \"2025-03-28T10:06:08.770326\",\n</code></pre> <p>You need to update these to the new dates of your file. Once updated, reload the package and run \"reset_config\" to update your config to the new default.</p>"},{"location":"uploading-new-files/#upload-the-files-to-zenodo","title":"Upload the files to zenodo\u00b6","text":"<p>You need to go to the zenodo listing for the Pandora models, click new version, and then upload the new files.</p>"},{"location":"uploading-new-files/#update-the-zenodo-link-in-the-configuration-file-for-pandorapsf","title":"Update the zenodo link in the configuration file for <code>pandorapsf</code>\u00b6","text":"<p>In the config file there is a link to Zenodo, e.g.</p> <pre><code>        \"vis_psf_download_location\": \"https://zenodo.org/records/15101982/files/pandora_vis_psf.fits?download=1\",\n        \"nir_psf_download_location\": \"https://zenodo.org/records/15101982/files/pandora_nir_psf.fits?download=1\",\n</code></pre> <p>Update these to reflect your new files</p>"},{"location":"uploading-new-files/#build-the-low-resolution-fallback-files","title":"Build the low resolution fallback files\u00b6","text":"<p>We store a very small version of these files as a fallback within the package directory. This is so that a single PSF can be evaluated if the package is pip installed without ever downloading the full grid files. Run</p> <pre>pp.utils.make_lowres_package_data()\n</pre> <p>To make this package date</p>"},{"location":"uploading-new-files/#check-the-files","title":"Check the files\u00b6","text":"<p>Move the files you've created to the data directory for the package, and check that everything works as expected. If not, repeat the above steps.</p>"},{"location":"uploading-new-files/#rerun-the-docs-notebooks-and-push-to-github","title":"Rerun the docs notebooks and push to github\u00b6","text":"<p>Go into the <code>docs</code> folder and rerun all the tutorials to update the figures. Add all the changes to git and push to GitHub.</p>"},{"location":"uploading-new-files/#update-the-package","title":"Update the package\u00b6","text":"<p>In the pyproject.toml file, update the version number, and then poetry build and poetry release.</p>"}]}